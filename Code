import numpy as np
import numpy.random as rd
from numpy import exp

#Programme qui renvoie la liste des voisins d'un point de la grille (i,j)
def voisins(Grille,i,j):
    n=len(Grille[1])
    if i ==1:
        if j==1 :
            return [(1,2),(2,1)]
        elif j==n:
            return [(1,n-1),(2,n)]
        return [(1,j-1),(1,j+1),(2,j)]
    elif i==n:
        if j==1 :
            return [(n-1,1),(n,2)]
        elif j==n:
            return [(n,n-1),(n-1,n)]
        return [(n,j-1),(1,j+1),(n-1,j)]
    elif j==1 :
        return [(i-1,1),(i+1,1),(i,2)]
    elif j==n :
        return [(i-1,n),(i+1,n),(i,n-1)]
    else :
        return [(i+1,j),(i-1,j),(i,j-1),(i,j+1)]

#Attention ! Pour l'instant, vu comme c'est construit, un criminel peut se déplacer PLUSIEURS fois dans une même boucle ! Pour éviter ça, il faudrait instaurer un système de blâme dans la ville d'arrivée, qui serait à décompter du nombre de criminels dans la maison (et on réinitialiserait tous les compteurs à chaque début de session).

def Short1(A_0, Gamma, l, taille, Omega, Eta, dt, Theta):
    #Formation de la grille et des matrices importantes
    Grille = [(i,j) for i in range(taille) for j in range(taille)]
    Bbar=(Gamma*Theta)/Omega
    nbar=(Gamma*dt)/(1-exp(-(A_0+Bbar)*dt))
    
    if int(nbar)<1:
        nombre=int(nbar*taille**2)
    Criminel=rd.randint(0, 2*int(nbar),(taille,taille)) #Matrice aléatoire d'entiers, de moyenne nbar. Matrice du nombre de criminels à chaque point


    A=A_0*np.ones((taille,taille)) #Matrice des attractivités
    B=Bbar*np.ones((taille,taille)) #Matrice des attractivités dynamiques


    #Simulation
    for t in range(730*dt):
        for s in Grille :
            s=(i,j)
            E=0 #Compteur du nombre de crime qui a lieu au point (i,j) au cours de l'intervalle de temps dt. L'intervalle de temps vient de commencer, donc aucun crime n'a encore été commis au noeud s pendant l'intervalle
            random.seed(t+i*j)
            #Introduction d'un criminel avec la probabilité Gamma
            r =random(0,1)
            if r<=Gamma:
                Criminel[i,j]+=1

            #Début de la boucle criminelle
            if Criminels[s]!=0: #S'il y a des criminels présents sur place
                for l in Criminel[i,j]:
                    p=1-exp(-A[i,j]*dt)
                    v=rd.random()
                    if v<=p: #Cas où la maison est effectivement cambriolée
                        E+=1
                    else :
                        voisins=voisins(Grille,i,j)
                        L=[]
                        S=0
                        for l in voisins:
                            S+=A[l[0],l[1]]
                        for k in voisins: #Définir voisins, et différencier coins/bords
                            L.append(A[k[0],k[1]]/S)
                        choix=rd.choice(voisins,1,p=L)[0]
                        Criminel[choix[0],choix[1]]
                            #Choisir avec la proba Q[s][k] de partir chez le voisin k, sachant qu'il est obligé de partir
                        Criminel[i,j]-=1 #Dans les deux cas, le criminel sera parti

            #Recalcul de B
            D=B[s](1-Omega*dt)+Theta*E
            if D>=0:
                B[s]=D
            else :
                B[s]=0

    return B
    #Partie graphique

def Short(A_0, Gamma, l, taille, Omega, Eta, dt, Theta):
    #Formation de la grille et des matrices importantes
    Grille = [(i,j) for i in range(taille) for j in range(taille)]
    Bbar=(Gamma*Theta)/Omega
    nbar=(Gamma*dt)/(1-exp(-(A_0+Bbar)*dt))
    return(Bbar,nbar)



